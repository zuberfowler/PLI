*PROCESS;
 INSERT:  PROCEDURE(ADD_NODE, ROOT_PTR)  REORDER;

 /*********************************************************************/
 /*                                                                   */
 /* THIS PROCEDURE DOES ADDITIONS TO A BINARY TREE WHICH IS TO BE     */
 /* CONSTRUCTED FOLLOWING THE PRINCIPLES OF AVL RELATIVE BALANCING    */
 /* RELATIONSHIPS.  FOUR DIFFERENT ROTATIONS ARE EMPLOYED TO MAINTAIN */
 /* THE RELATIVE HEIGHTS OF LEFT AND RIGHT SUBTREES WITHIN ONE LEVEL  */
 /* OF EACH OTHER.  THIS APPLIES TO ALL SUBTREES IN THE TREE.  THE    */
 /* BALANCING IS ACCOMPLISHED WITH A FIELD IN EACH NODE WHICH         */
 /* REPRESENTS THE HEIGHT OF ITS LEFT SUBTREE MINUS THE HEIGHT OF ITS */
 /* RIGHT SUBTREE.  IN PART ONE THE INSERTION POINT IS FOUND FOR THE  */
 /* NEW NODE OR IF IT IS ALREADY IN THE TREE THE ROUTINE IS           */
 /* TERMINATED.  IN PART TWO THE NEW NODE IS INSERTED INTO THE TREE   */
 /* AND ALL THE NODE FROM THE LAST IMBALANCE (TILT) TO THE INSERTION  */
 /* POINT ARE REBALANCED.  BY DEFINITION OF THE TILT ALL THE NODES    */
 /* DOWN THE TREE FROM THAT POINT HAVE A PREVIOUS BALANCE OF ZERO,    */
 /* AND WILL BE CHANGE TO PLUS OR MINUS ONE DEPENDING ON WHETHER THE  */
 /* NEW NODE WAS ADDED TO THE LEFT OR RIGHT SUBTREE OF TILT.          */
 /*                                                                   */
 /*********************************************************************/


 /* THE NEW NODE VALUE TO BE ADDED TO THE TREE */
 DECLARE  ADD_NODE  FIXED DECIMAL(5);

 /* THE POINTER TO THE ROOT NODE OF THE TREE */
 DECLARE  ROOT_PTR  PTR;

 /* COMPLIER FUNCTIONS */
 DECLARE  NULL  BUILTIN;
1/* POINTS TO THE LAST NODE UP THE TREE FROM THE INSERTION POINT WHICH
    HAD A BALANCE OF PLUS OR MINUS ONE */
 DECLARE  TILT  PTR;

 /* POINTS TO THE PARENT OF TILT */
 DECLARE  PARENT_TILT  PTR;

 /* POINTS TO EITHER CHILD OF TILT DEPENDING ON WHETHER THE INSERTION
    POINT IS ON THE LEFT OR RIGHT SUBTREE OF TILT */
 DECLARE  CHILD_TILT  PTR;

 /* POINTS TO A GRANDCHILD OF TILT DEPENDING ON THE INSERTION POINT */
 DECLARE  GRAND_TILT  PTR;

 /* POINTS TO A LEFT GREAT GRANDCHILD OF TILT DEPENDING ON THE
    INSERTION POINT */
 DECLARE  LGREAT_TILT  PTR;

 /* POINTS TO A RIGHT GREAT GRANDCHILD OF TILT DEPENDING ON THE
    INSERTION POINT */
 DECLARE  RGREAT_TILT  PTR;

 /* POINTS TO THE CURRENT POSITION IN THE TREE */
 DECLARE  CURPOS  PTR;

 /* POINTS TO THE PARENT OF THE CURRENT POSITION IN THE TREE */
 DECLARE  PARENT_CURPOS  PTR;

 /* HOLD THE ADDED WEIGHT TO THE TREE BY THE INSERTION, USED FOR
    ADJUSTING THE SUBTREE UNDER TILT */
 DECLARE  ADD_WEIGHT  FIXED DECIMAL(1);

 /* POINTS TO A NEWLY ALOCATED NODE IN THE TREE */
 DECLARE  NODE_PTR  PTR;

 /* THE NODE STRUCTURE OF EACH NODE IN THE TREE */
 /* UNLESS EXPLICITLY REFERED TO WITH A POINTER IT REFERS TO A NEWLY
    ALLOCATED NODE */
 DECLARE
   1  TREE  BASED(NODE_PTR),
      2  LEFT_CHILD   PTR,
      2  RIGHT_CHILD  PTR,
      2  BALANCE      FIXED DECIMAL(1),
      2  VALUE        FIXED DECIMAL(5);
1/* THIS IS AN EXTREME CASE WHERE THE TREE WAS PREVIOUSLY EMPTY */
 IF ROOT_PTR  =  NULL
     THEN DO;
          ALLOCATE TREE;
          VALUE = ADD_NODE;
          ROOT_PTR = NODE_PTR;
          BALANCE = 0;
          LEFT_CHILD = NULL;
          RIGHT_CHILD = NULL;
          RETURN;
          END;


 /* <<<< PART ONE >>>> */
 /* LOCATE THE INSERTION POINT FOR THE NODE TO BE ADDED */

 /* INITIALIZE */
 PARENT_TILT = NULL;
 TILT = ROOT_PTR;
 PARENT_CURPOS = NULL;
 CURPOS = ROOT_PTR;

 FIND_INSERT_PT:  /* LOCATE A SUITABLE POINT IN THE TREE FOR INSERTION
 OR FIND THE INSERTION VALUE ALREADY IN THE TREE */
 DO WHILE(CURPOS ^= NULL);

     /* KEEP TRACK OF TILT */
     IF CURPOS-> BALANCE  ^=  0
         THEN DO;
              TILT = CURPOS;
              PARENT_TILT = PARENT_CURPOS;
              END;

     SELECT;
         /* GO DOWN LEFT SUBTREE */
         WHEN(ADD_NODE  <  CURPOS-> VALUE) DO;
             PARENT_CURPOS = CURPOS;
             CURPOS = CURPOS-> LEFT_CHILD;
             END;
         /* GO DOWN RIGHT SUBTREE */
         WHEN(ADD_NODE  >  CURPOS-> VALUE) DO;
             PARENT_CURPOS = CURPOS;
             CURPOS = CURPOS-> RIGHT_CHILD;
             END;
         /* ALREADY IN TREE */
         OTHERWISE RETURN;
         END;

     END FIND_INSERT_PT;
1/* <<<< PART TWO >>>> */
 /* INSERT THE ADD_NODE AND REBALANCE THE TREE IF NECESSARY */

 /* BUILD A NEW NODE WITH THE ADD_NODE VALUE */
 ALLOCATE TREE;
 VALUE = ADD_NODE;
 LEFT_CHILD = NULL;
 RIGHT_CHILD = NULL;
 BALANCE = 0;

 /* CONNECT THE NEW NODE TO THE TREE */
 IF ADD_NODE  <  PARENT_CURPOS-> VALUE
     THEN PARENT_CURPOS-> LEFT_CHILD = NODE_PTR;
     ELSE PARENT_CURPOS-> RIGHT_CHILD = NODE_PTR;

 /* ADJUST BALANCE OF NODES ON PATH FROM TILT TO PARENT_CURPOS */
 IF ADD_NODE  >  TILT-> VALUE
     /* INSERT AS A RIGHT SUBTREE OF TILT */
     THEN DO;
          CURPOS = TILT-> RIGHT_CHILD;
          CHILD_TILT = CURPOS;
          ADD_WEIGHT = -1;
          END;
     /* INSERT AS A LEFT SUBTREE OF TILT */
     ELSE DO;
          CURPOS = TILT-> LEFT_CHILD;
          CHILD_TILT = CURPOS;
          ADD_WEIGHT = 1;
          END;

 SLIDE_DOWN:  /* WORK DOWN TREE FROM TILT ADJUSTING BALANCES */
 DO WHILE(CURPOS ^= NODE_PTR);
     IF ADD_NODE  >  CURPOS-> VALUE
         /* HEIGHT OF RIGHT SUBTREE INCREASES BY ONE */
         THEN DO;
              CURPOS-> BALANCE = -1;
              CURPOS = CURPOS-> RIGHT_CHILD;
              END;
         /* HEIGHT OF LEFT SUBTREE INCREASES BY ONE */
         ELSE DO;
              CURPOS-> BALANCE = 1;
              CURPOS = CURPOS-> LEFT_CHILD;
              END;
     END SLIDE_DOWN;
1CHECK_BALANCE:  /* IS THE TREE UNBALANCED? */
 SELECT(TILT-> BALANCE);

     /* TILT WAS THE ROOT (REALLY NEVER 'TILTED') */
     WHEN(0)  TILT-> BALANCE = ADD_WEIGHT;

     /* THE ADDITION BALANCED OUT A PREVIOUS IMBALANCE */
     WHEN(-ADD_WEIGHT)  TILT-> BALANCE = 0;

     /* THE ADDITION CAUSED US AN IMBALANCE GREATER THAN ONE */
     OTHERWISE REBALANCE:  DO;

         IF ADD_WEIGHT  =  1
             THEN CALL LEFT_IMBALANCE;
             ELSE CALL RIGHT_IMBALANCE;

         /* SUBTREE WITH ROOT CHILD_TILT HAS BEEN REBALANCED AND IS THE
            NEW SUBTREE OF PARENT_TILT */
         SELECT;

             /* AFTER ROTATION WE ALSO GET A NEW ROOT FOR THE TREE */
             WHEN(PARENT_TILT  =  NULL)
                 ROOT_PTR = CHILD_TILT;

             /* RECONNECT THE ROTATED SUBTREE TO THE LEFT LINK ABOVE */
             WHEN(TILT  =  PARENT_TILT-> LEFT_CHILD)
                 PARENT_TILT-> LEFT_CHILD = CHILD_TILT;

             /* RECONNECT THE ROTATED SUBTREE TO THE RIGHT LINK ABOVE */
             WHEN(TILT  =  PARENT_TILT-> RIGHT_CHILD)
                 PARENT_TILT-> RIGHT_CHILD = CHILD_TILT;
             END;

         END REBALANCE;

     END CHECK_BALANCE;
1LEFT_IMBALANCE:  PROCEDURE;

 /*********************************************************************/
 /*                                                                   */
 /* TREE IS IMBALANCED BY AN ADDITION TO THE LEFT SUBTREE OF TILT. IF */
 /* THE INSERTION WAS TO THE LEFT SUBTREE OF THE LEFT SUBTREE OF TILT */
 /* THEN THE ROTATION IS AN LL TYPE ROTATION.  IF THE INSERT WAS TO   */
 /* THE RIGHT SUBTREE OF THE LEFT SUBTREE OF TILT THEN THE INSERTION  */
 /* REQUIRES AN LR TYPE ROTATION.  THIS PROCEDURE IS A MIRROR IMAGE   */
 /* OF RIGHT_IMBALANCE.                                               */
 /*                                                                   */
 /*********************************************************************/


 IF CHILD_TILT-> BALANCE  =  1

     /* LL TYPE ROTATION */
     THEN DO;
          TILT-> LEFT_CHILD = CHILD_TILT-> RIGHT_CHILD;
          CHILD_TILT-> RIGHT_CHILD = TILT;
          TILT-> BALANCE = 0;
          CHILD_TILT-> BALANCE = 0;
          END;

1    /* LR TYPE ROTATION */
     ELSE DO;
          /* MAKE GRAND_TILT NEW ROOT OF SUBTREE */
          GRAND_TILT = CHILD_TILT-> RIGHT_CHILD;
          LGREAT_TILT = GRAND_TILT-> LEFT_CHILD;
          RGREAT_TILT = GRAND_TILT-> RIGHT_CHILD;
          CHILD_TILT-> RIGHT_CHILD = LGREAT_TILT;
          TILT-> LEFT_CHILD = RGREAT_TILT;
          GRAND_TILT-> LEFT_CHILD = CHILD_TILT;
          GRAND_TILT-> RIGHT_CHILD = TILT;

          /* THREE DIFFERENT SUBCASES OF LR TYPE ROTATION */
          SELECT;
              /* WAS ADDED TO LEFT SUBTREE UNDER GRAND_TILT */
              WHEN(GRAND_TILT-> BALANCE  =  1) DO;
                  TILT-> BALANCE = -1;
                  CHILD_TILT-> BALANCE = 0;
                  END;
              /* WAS ADDED TO RIGHT SUBTREE UNDER GRAND_TILT */
              WHEN(GRAND_TILT-> BALANCE  =  -1) DO;
                  CHILD_TILT-> BALANCE = 1;
                  TILT-> BALANCE = 0;
                  END;
              /* SIMPLE CASE */
              OTHERWISE DO;
                  CHILD_TILT-> BALANCE = 0;
                  TILT-> BALANCE = 0;
                  END;
              END;

          GRAND_TILT-> BALANCE = 0;
          /* CHILD_TILT MUST POINT TO THE NEW ROOT OF THE SUBTREE */
          CHILD_TILT = GRAND_TILT;

          END;

 END LEFT_IMBALANCE;
1RIGHT_IMBALANCE:  PROCEDURE;

 /*********************************************************************/
 /*                                                                   */
 /* TREE IS IMBALANCED BY AN ADDITION TO THE RIGHT SUBTREE OF TILT.   */
 /* IF THE INSERTION WAS TO THE RIGHT SUBTREE OF THE RIGHT SUBTREE OF */
 /* TILT THEN IT REQUIRES AN RR TYPE ROTATION.  IF THE INSERTION WAS  */
 /* TO THE LEFT SUBTREE OF THE RIGHT SUBTREE OF TILT THEN IT REQUIRES */
 /* AN RL TYPE ROTATION.  THIS PROCEDURE IS A MIRROR IMAGE OF         */
 /* LEFT_IMBALANCE.                                                   */
 /*                                                                   */
 /*********************************************************************/


 IF CHILD_TILT-> BALANCE  =  -1

     /* RR TYPE ROTATION */
     THEN DO;
          TILT-> RIGHT_CHILD = CHILD_TILT-> LEFT_CHILD;
          CHILD_TILT-> LEFT_CHILD = TILT;
          TILT-> BALANCE = 0;
          CHILD_TILT-> BALANCE = 0;
          END;

1    /* RL TYPE ROTATION */
     ELSE DO;
          /* MAKE GRAND_TILT NEW ROOT OF SUBTREE */
          GRAND_TILT = CHILD_TILT-> LEFT_CHILD;
          LGREAT_TILT = GRAND_TILT-> LEFT_CHILD;
          RGREAT_TILT = GRAND_TILT-> RIGHT_CHILD;
          CHILD_TILT-> LEFT_CHILD = RGREAT_TILT;
          TILT-> RIGHT_CHILD = LGREAT_TILT;
          GRAND_TILT-> RIGHT_CHILD = CHILD_TILT;
          GRAND_TILT-> LEFT_CHILD = TILT;

          /* THREE DIFFERENT SUBCASES OF RL TYPE ROTATION */
          SELECT;
              /* WAS ADDED TO RIGHT SUBTREE UNDER GRAND_TILT */
              WHEN(GRAND_TILT-> BALANCE  =  -1) DO;
                  TILT-> BALANCE = 1;
                  CHILD_TILT-> BALANCE = 0;
                  END;
              /* WAS ADDED TO LEFT SUBTREE UNDER GRAND_TILT */
              WHEN(GRAND_TILT-> BALANCE  =  1) DO;
                  CHILD_TILT-> BALANCE = -1;
                  TILT-> BALANCE = 0;
                  END;
              /* SIMPLE CASE */
              OTHERWISE DO;
                  CHILD_TILT-> BALANCE = 0;
                  TILT-> BALANCE = 0;
                  END;
              END;

          GRAND_TILT-> BALANCE = 0;
          /* CHILD_TILT MUST POINT TO THE NEW ROOT OF THE SUBTREE */
          CHILD_TILT = GRAND_TILT;

          END;

 END RIGHT_IMBALANCE;
 END INSERT;
*PROCESS;
 SEARCH:  PROCEDURE(FIND_NODE, ROOT_PTR) RETURNS(PTR)  REORDER;

 /*********************************************************************/
 /*                                                                   */
 /* THIS PROCEDURE DOES A BINARY TREE SEARCH FOR A VALUE PASSED AS A  */
 /* PARAMETER.  THE TREE TO BE SEARCHED IS POINTED TO BY THE SECOND   */
 /* PARAMETER AND THE POINTER TO THE NODE WHERE THE VALUE IS FOUND IS */
 /* RETURNED BY THE PROCEDURE AS A FUNCTION.  IF THE VALUE IS NOT      /
 /* FOUND, THE NULL VALUE IS RETURNED.                                */
 /*                                                                   */
 /*********************************************************************/


 /* THE NEW NODE VALUE TO BE ADDED TO THE TREE */
 DECLARE  FIND_NODE  FIXED DECIMAL(5);

 /* THE POINTER TO THE ROOT NODE OF THE TREE */
 DECLARE  ROOT_PTR  PTR;

 /* COMPLIER FUNCTIONS */
 DECLARE  NULL  BUILTIN;

 /* POINTS TO A NODE IN THE TREE */
 DECLARE  NODE_PTR  PTR;

 /* THE NODE STRUCTURE OF EACH NODE IN THE TREE */
 /* NODE_PTR IS SET TO DESIRED NODE BEFORE REFERENCING ANY ELEMENT */
 DECLARE
   1  TREE  BASED(NODE_PTR),
      2  LEFT_CHILD   PTR,
      2  RIGHT_CHILD  PTR,
      2  BALANCE      FIXED DECIMAL(1),
      2  VALUE        FIXED DECIMAL(5);
1/* INITIALIZE */
 NODE_PTR = ROOT_PTR;

 LOOK_DOWN:  /* LOCATE POSITION OF THE NODE IN THE TREE */
 DO WHILE(NODE_PTR ^= NULL);

     SELECT;
         /* GO DOWN LEFT SUBTREE */
         WHEN(FIND_NODE < VALUE) NODE_PTR = LEFT_CHILD;

         /* GO DOWN RIGHT SUBTREE */
         WHEN(FIND_NODE > VALUE) NODE_PTR = RIGHT_CHILD;

         /* SUCCESSFUL SEARCH */
         OTHERWISE RETURN(NODE_PTR);
         END;

     END LOOK_DOWN;

 /* UNSUCCESSFUL SEARCH */
 RETURN(NULL);

 END SEARCH;
*PROCESS;
 HEIGHT:  PROCEDURE(ROOT_PTR) RETURNS(FIXED BINARY(31)) REORDER;

 /*********************************************************************/
 /*                                                                   */
 /* THIS PROCEDURE IS FOR ANALYSIS OF AN AVL TREE.  IT COMPUTES THE   */
 /* HEIGHT OF THE TREE AND RETURNS THE HEIGHT AS THE VALUE OF THE     */
 /* FUNCTION.  TO DO THIS IT TAKES THE LONGEST PATH FROM ROOT TO LEAF */
 /* BY LOOKING AT THE BALANCE FIELDS OF THE NODES.                    */
 /*                                                                   */
 /*********************************************************************/


 /* THE POINTER TO THE ROOT NODE OF THE TREE */
 DECLARE  ROOT_PTR  PTR;

 /* HEIGHT COUNTER */
 DECLARE  HEIGHT_SPAN  FIXED BINARY(31) INIT(0);

 /* COMPLIER FUNCTIONS */
 DECLARE  NULL  BUILTIN;

 /* POINTS TO A NODE IN THE TREE */
 DECLARE  NODE_PTR  PTR;

 /* THE NODE STRUCTURE OF EACH NODE IN THE TREE */
 /* NODE_PTR IS SET BEFORE ANY REFERENCE TO PART OF THE NODE */
 DECLARE
   1  TREE  BASED(NODE_PTR),
      2  LEFT_CHILD   PTR,
      2  RIGHT_CHILD  PTR,
      2  BALANCE      FIXED DECIMAL(1),
      2  VALUE        FIXED DECIMAL(5);


 /* INITIALIZE */
 NODE_PTR = ROOT_PTR;

 TOP_DOWN:   /* GO THROUGH WHOLE TREE FROM TOP TO BOTTOM */
 DO WHILE(NODE_PTR ^= NULL);

     /* KEEP TRACK OF THE HEIGHT BY COUNTING EACH LEVEL */
     HEIGHT_SPAN = HEIGHT_SPAN + 1;

     IF BALANCE = 1
         /* GO DOWN LEFT SUBTREE BECAUSE IT'S LONGER */
         THEN NODE_PTR = LEFT_CHILD;

         /* GO DOWN RIGHT SUBTREE BECAUSE IT'S LONGER OR THE SAME */
         ELSE NODE_PTR = RIGHT_CHILD;

     END TOP_DOWN;

 RETURN(HEIGHT_SPAN);
 END HEIGHT;
