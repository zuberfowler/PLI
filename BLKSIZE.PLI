*PROCESS NM;
 BLKSIZE:  PROCEDURE OPTIONS(MAIN,REENTRANT) REORDER;
 DECLARE  PGMID  CHAR(35) VARYING STATIC EXTERNAL
     INIT('BLKSIZE V1.0  BY CLYDE THOMAS ZUBER');

 DECLARE  PLIXOPT  CHAR(9) VARYING STATIC EXTERNAL INIT('ISA(128K)');

 /*********************************************************************/
 /*                                                                   */
 /* PURPOSE:  TO PROVIDE THE USER WITH ENOUGH INFORMATION SO THAT HE  */
 /*           CAN EASILY CHOOSE THE BEST BLKSIZE FOR A GIVEN LRECL.   */
 /*                                                                   */
 /* METHOD:   THIS PROGRAM TAKES A LOGICAL RECORD LENGTH WITH OR      */
 /*           WITHOUT KEYS AND COMPUTES ALL POSSIBLE BLOCK SIZES.  IT */
 /*           THEN EVALUATES THEIR SPACE EFFECTIVENESS ON FOUR DIRECT */
 /*           ACCESS DEVICE TYPES.  IT THEN SORTS THEM IN BEST FIRST  */
 /*           ORDER FOR THE DEVICE TYPES SELECTED AND PUTS OUT THE    */
 /*           INFORMATION IN AN ISPF TABLE.                           */
 /*                                                                   */
 /* INPUT:    THIS PROGRAM IS INVOKED FROM AN ISPF PANEL WHICH        */
 /*           SETS UP IDENTIFIERS WHICH PROVIDE THE FOLLOWING INPUT   */
 /*           TO THIS PROGRAM:  LRECL, KEYLEN, (YES OR NO): 3330,     */
 /*           3340, 3350, 3380.                                       */
 /*                                                                   */
 /* OUTPUT:   ISPF TABLE.                                             */
 /*                                                                   */
 /*********************************************************************/
1/* INVOKED FUNCTIONS */
 DECLARE  ISPLINK  ENTRY OPTIONS(ASM, INTER, RETCODE);
 DECLARE  RATESRT  ENTRY; /* CUSTOMIZED HEAPSRT V1.0 PROCEDURE */
 DECLARE  (CEIL, FLOAT, MAX, PLIRETV)  BUILTIN;

 /* NON-ISPF PROGRAM WORKING IDENTIFIERS */
 DECLARE  LAST_RATING  FIXED BINARY(31);
 DECLARE  KEYLEN       FIXED BINARY(31);
 DECLARE  DATALEN      FIXED BINARY(31);
 DECLARE  EXT          FIXED BINARY(31);
 DECLARE  SUB          FIXED BINARY(31);
 DECLARE  DEVT         FIXED BINARY;
 DECLARE  KEYED        FIXED BINARY;
 DECLARE  CONSIDER(4)  BIT(1);

 DECLARE /* STRUCTURE FOR SORTING BLKSIZES BY THEIR RATING */
     1  RATER(*) CONTROLLED,
        2  BLKSIZE  FIXED BINARY(31),
        2  RATING   FIXED BINARY(31);

 /* NON-ISPF CONSTANT IDENTIFIERS */
 DECLARE  TRKMAX(4)  FIXED BINARY(31) STATIC
          INIT(13165, 8368, 19254, 47968); /* 3330, 3340, 3350, 3380 */
 DECLARE  BLK_OVERHD(0:1, 4)  FIXED BINARY(31) STATIC
          /*  3330, 3340, 3350, 3380 */
          INIT(135,  167,  185,  480,    /* WITHOUT KEYS */
               191,  242,  267,  704);   /* WITH KEYS */
 DECLARE  NO   BIT(1) STATIC INIT('0'B);
 DECLARE  YES  BIT(1) STATIC INIT('1'B);

 /* ISPF CONSTANTS (KEYWORDS, PANEL NAME, LENGTH PARM) */
 DECLARE  DISPLAY    CHAR(8)  STATIC INIT('DISPLAY');
 DECLARE  CHAR       CHAR(4)  STATIC INIT('CHAR');
 DECLARE  COPY       CHAR(8)  STATIC INIT('COPY');
 DECLARE  FIXED      CHAR(8)  STATIC INIT('FIXED');
 DECLARE  VDEFINE    CHAR(8)  STATIC INIT('VDEFINE');
 DECLARE  NOWRITE    CHAR(8)  STATIC INIT('NOWRITE');
 DECLARE  TBCREATE   CHAR(8)  STATIC INIT('TBCREATE');
 DECLARE  TBDISPL    CHAR(8)  STATIC INIT('TBDISPL');
 DECLARE  TBADD      CHAR(8)  STATIC INIT('TBADD');
 DECLARE  TBTOP      CHAR(8)  STATIC INIT('TBTOP');
 DECLARE  TBEND      CHAR(8)  STATIC INIT('TBEND');
 DECLARE  BLKSIZE1   CHAR(8)  STATIC INIT('BLKSIZE1');
 DECLARE  L_VAR4     FIXED BINARY(31) STATIC INIT(4);
1/* ISPF DEFINED IDENTIFIER STORAGE AREAS */
 DECLARE  LRECL            FIXED BINARY(31);
 DECLARE  KEYLN            FIXED BINARY(31); /* KEY LENGTH */
 DECLARE  BLKI             FIXED BINARY(31); /* BLOCKING FACTOR */
 DECLARE  BLKSI            FIXED BINARY(31); /* BLKSIZE */
 DECLARE  RATI             FIXED BINARY(31); /* RATING */
 DECLARE  #BLKS_TRK(4)     FIXED BINARY(31);
 DECLARE  BYTES_USED(4)    FIXED BINARY(31);
 DECLARE  BYTES_WASTED(4)  FIXED BINARY(31);
 DECLARE  BYTES_OVERHD(4)  FIXED BINARY(31);
 DECLARE  U(4)             CHAR(4); /* YES/NO VALUES FOR UNITS */

 /* ISPF CONSTANTS (IDENTIFIER NAMES) */
 DECLARE  N_LRECL  CHAR(8) STATIC INIT('(LRECL)');
 DECLARE  N_KEYLN  CHAR(8) STATIC INIT('(KEYLN)');
 DECLARE  N_BLKI   CHAR(8) STATIC INIT('(BLKI)');
 DECLARE  N_BLKSI  CHAR(8) STATIC INIT('(BLKSI)');
 DECLARE  N_RATI   CHAR(8) STATIC INIT('(RATI)');
 DECLARE  N_#BLKS_TRK(4)     CHAR(8) STATIC
          INIT('(BT3)','(BT4)','(BT5)','(BT8)');
 DECLARE  N_BYTES_USED(4)    CHAR(8) STATIC
          INIT('(BU3)','(BU4)','(BU5)','(BU8)');
 DECLARE  N_BYTES_WASTED(4)  CHAR(8) STATIC
          INIT('(BW3)','(BW4)','(BW5)','(BW8)');
 DECLARE  N_BYTES_OVERHD(4)  CHAR(8) STATIC
          INIT('(OH3)','(OH4)','(OH5)','(OH8)');
 DECLARE  N_U(4)  CHAR(8) STATIC INIT('(U30)','(U40)','(U50)','(U80)');

 DECLARE  TABNAMES  CHAR(81) STATIC INIT( '(BLKI BLKSI RATI BT3 BU3 BW3
 OH3 BT4 BU4 BW4 OH4 BT5 BU5 BW5 OH5 BT8 BU8 BW8 OH8)');
1/* INITIALIZE IDENTIFIERS FROM INVOKING PANEL */
 CALL ISPLINK(VDEFINE, N_LRECL, LRECL, FIXED, L_VAR4, COPY);
 CALL ISPLINK(VDEFINE, N_KEYLN, KEYLN, FIXED, L_VAR4, COPY);
 CALL ISPLINK(VDEFINE, N_BLKI, BLKI, FIXED, L_VAR4);
 CALL ISPLINK(VDEFINE, N_BLKSI, BLKSI, FIXED, L_VAR4);
 CALL ISPLINK(VDEFINE, N_RATI, RATI, FIXED, L_VAR4);

 /* INITIALIZE IDENTIFIERS FROM INVOKING PANEL AND DEFINE NEW ONES */
 DO DEVT = 1 TO 4;
     CALL ISPLINK(VDEFINE, N_U(DEVT), U(DEVT), CHAR, L_VAR4, COPY);
     SELECT(U(DEVT));
         WHEN('YES') CONSIDER(DEVT) = YES;
         WHEN('NO')  CONSIDER(DEVT) = NO;
         END;
     CALL ISPLINK(VDEFINE, N_#BLKS_TRK(DEVT), #BLKS_TRK(DEVT),
         FIXED, L_VAR4);
     CALL ISPLINK(VDEFINE, N_BYTES_USED(DEVT), BYTES_USED(DEVT),
         FIXED, L_VAR4);
     CALL ISPLINK(VDEFINE, N_BYTES_WASTED(DEVT), BYTES_WASTED(DEVT),
         FIXED, L_VAR4);
     CALL ISPLINK(VDEFINE, N_BYTES_OVERHD(DEVT), BYTES_OVERHD(DEVT),
         FIXED, L_VAR4);
     END;

 /* SET OVERHEAD SUBSCRIPT FOR KEYS OR NO KEYS */
 IF KEYLN = 0
     THEN KEYED = 0;
     ELSE KEYED = 1;

 /* COMPUTE SIZE OF BLKSIZE/RATING ARRAY AND ALLOCATE STORAGE */
 DO EXT = 1 BY 1 WHILE((LRECL * EXT) <= 47476);
     END;
 EXT= EXT - 1;
 ALLOCATE RATER(EXT);
 RATING = 0;
1FOR_RATES:  /* INITIALIZE RATER STRUCTURE FOR SORTING BY RATING */
 DO BLKI = 1 TO EXT;
     BLKSIZE(BLKI) = LRECL * BLKI;
     DO DEVT = 1 TO 4;
         IF DEVT = 4
             THEN DO;
                  IF KEYLN = 0
                      THEN KEYLEN = 0;
                      ELSE KEYLEN = CEIL((FLOAT(KEYLN) + 12) / 32) * 32;
                  DATALEN = CEIL((FLOAT(BLKSIZE(BLKI)) + 12) / 32) * 32;
                  END;
             ELSE DO;
                  KEYLEN = KEYLN;
                  DATALEN = BLKSIZE(BLKI);
                  END;
         #BLKS_TRK(DEVT) = TRKMAX(DEVT) /
             (KEYLEN + DATALEN + BLK_OVERHD(KEYED, DEVT));
         BYTES_USED(DEVT) = (KEYLN + BLKSIZE(BLKI)) * #BLKS_TRK(DEVT);
         BYTES_OVERHD(DEVT) = TRKMAX(DEVT) - BYTES_USED(DEVT);
         IF CONSIDER(DEVT)
             THEN RATING(BLKI) = RATING(BLKI) + BYTES_USED(DEVT) -
                     BYTES_OVERHD(DEVT);
         END;
     END FOR_RATES;

 /* SORT AND PREPARE FOR TABLE OUTPUT */
 CALL RATESRT(RATER, EXT);
 CALL ISPLINK(TBCREATE, BLKSIZE1, ' ', TABNAMES, NOWRITE);
 RATI = 1;
 LAST_RATING = RATING(1);
1FOR_TABLE:  /* BUILD ISPF TABLE TO DISPLAY CALCULATED RESULTS */
 DO SUB = 1 TO EXT;
     BLKSI = BLKSIZE(SUB);
     BLKI = BLKSI / LRECL;
     IF RATING(SUB) < LAST_RATING
         THEN DO;
              RATI = RATI + 1;
              LAST_RATING = RATING(SUB);
              END;
     DO DEVT = 1 TO 4;
         IF DEVT = 4
             THEN DO;
                  IF KEYLN = 0
                      THEN KEYLEN = 0;
                      ELSE KEYLEN = CEIL((FLOAT(KEYLN) + 12) / 32) * 32;
                  DATALEN = CEIL((FLOAT(BLKSIZE(SUB)) + 12) / 32) * 32;
                  END;
             ELSE DO;
                  KEYLEN = KEYLN;
                  DATALEN = BLKSIZE(SUB);
                  END;
         #BLKS_TRK(DEVT) = TRKMAX(DEVT) /
             (KEYLEN + DATALEN + BLK_OVERHD(KEYED, DEVT));
         BYTES_USED(DEVT) = (KEYLN + BLKSIZE(SUB)) * #BLKS_TRK(DEVT);
         BYTES_OVERHD(DEVT) = TRKMAX(DEVT) - BYTES_USED(DEVT);
         BYTES_WASTED(DEVT) = BYTES_OVERHD(DEVT) -
             MAX((BLK_OVERHD(KEYED, DEVT) * #BLKS_TRK(DEVT)),
             BLK_OVERHD(KEYED, DEVT));
         END;
     CALL ISPLINK(TBADD, BLKSIZE1);
     END FOR_TABLE;

 /* CLEAN UP FOR TABLE DISPLAY */
 FREE RATER;
 CALL ISPLINK(TBTOP, BLKSIZE1);

 SHOW_TABLE:  /* DISPLAY TABLE AS UNTIL END KEY SIGNALED */
 DO WHILE(PLIRETV < 8);
     CALL ISPLINK(TBDISPL, BLKSIZE1, BLKSIZE1);
     END SHOW_TABLE;

 /* TELL ISPF TO GET RID OF TABLE */
 CALL ISPLINK(TBEND, BLKSIZE1);
1/*********************************************************************/
 /*                                                                   */
 /* FOLLOWING ARE APPROXIMATE MODELS OF THE ISPF PANELS USED IN       */
 /* CONJUNCTION WITH THIS PROGRAM.                                    */
 /*                                                                   */
 /*********************************************************************/
 /*
 %-------------------  OPTIMUM BLKSIZE CALCULATOR  ---------------------
 %OPTION ===>_OPT                                                      +
 %
 %  SELECT UNIT TYPES FOR CONSIDERATION+(YES OR NO):
 +
 +       3330  %===>_U30+
 +       3340  %===>_U40+
 +       3350  %===>_U50+
 +       3380  %===>_U80+
 +
 +
 +       LRECL %===>_LRECL+
 +       KEYLEN%===>_KEYLN+
 +
 +
 %  NOTE: +CALCULATION IS BASED ON DISK STORAGE UTILIZATION.  OTHER
 +  FACTORS SUCH AS MEMORY PAGE SIZE (4K/4096 BYTES) AND THE NUMBER OF
 +  BUFFERS BEING USED BY THE ACCESS METHOD (DEFAULTS TO 5) SHOULD ALSO
 +  BE CONSIDERED WHEN CHOOSING THE BLKSIZE.
 )INIT
  .CURSOR = LRECL
  &LRECL = ' '
  &KEYLN = 0
  IF (&U30 = ' ')
      &U30 = YES
  IF (&U40 = ' ')
      &U40 = NO
  IF (&U50 = ' ')
      &U50 = YES
  IF (&U80 = ' ')
      &U80 = YES
1)PROC
   VER(&LRECL,NONBLANK)
   VER(&LRECL,NUM)
   VER(&LRECL,RANGE,3,32767)
   VER(&KEYLN,NONBLANK)
   VER(&KEYLN,NUM)
   VER(&KEYLN,RANGE,0,255)
   VER(&U30,NONBLANK)
   VER(&U40,NONBLANK)
   VER(&U50,NONBLANK)
   VER(&U80,NONBLANK)
   &U30 = TRANS(&U30  Y,YES N,NO YE,YES YES,YES NO,NO)
   &U40 = TRANS(&U40  Y,YES N,NO YE,YES YES,YES NO,NO)
   &U50 = TRANS(&U50  Y,YES N,NO YE,YES YES,YES NO,NO)
   &U80 = TRANS(&U80  Y,YES N,NO YE,YES YES,YES NO,NO)
   VER(&U30,LIST,YES,NO)
   VER(&U40,LIST,YES,NO)
   VER(&U50,LIST,YES,NO)
   VER(&U80,LIST,YES,NO)
   VPUT (U30,U40,U50,U80) PROFILE
   VPUT (LRECL KEYLN) SHARED
   &ZSEL = TRANS(&OPT  ' ',' '  '*','?')
   IF (&ZSEL ^= '?')
       &ZSEL = 'PGM(BLKSIZE)'
 )END
1)ATTR
  DEFAULT(%+])
  $ TYPE(OUTPUT) INTENS(HIGH)
  @ TYPE(OUTPUT) INTENS(LOW)
 )BODY
 %OPTIMUM BLKSIZE CALCULATOR   LRECL=$LRECL%KEYLEN=$KEYLN%--------------
 %OPTION ===>]OPT                                     %SCROLL ===>]ZSCR+
 %BKNG BLKSIZE  RATING  UNIT/CON #BLKS/TRK  BYTES USED   WASTED OVERHEAD
 )MODEL
 +______________________________________________________________________
 @Z   + $Z    +   @Z  +$UN3 @U30+     @Z  +     @Z    +  @Z    + @Z    +
                       $UN4 @U40+     @Z  +     @Z    +  @Z    + @Z    +
                       $UN5 @U50+     @Z  +     @Z    +  @Z    + @Z    +
                       $UN8 @U80+     @Z  +     @Z    +  @Z    + @Z    +
 )INIT
  .HELP = BLKSIZET
  .ZVARS='(BLKI BLKSI RATI +
           BT3 BU3 BW3 OH3 +
           BT4 BU4 BW4 OH4 +
           BT5 BU5 BW5 OH5 +
           BT8 BU8 BW8 OH8)'
  &ZSCR = 'PAGE'
  &UN3 = '3330'
  &UN4 = '3340'
  &UN5 = '3350'
  &UN8 = '3380'
 )END
1%TUTORIAL ----------  OPTIMUM BLKSIZE CALCULATOR  ------------ TUTORIAL
 %OPTION ===>_OPT                                                      +
 %
 % PURPOSE:+ TO PROVIDE THE USER WITH ENOUGH INFORMATION SO THAT HE CAN
 +           EASILY CHOOSE THE BEST BLKSIZE FOR A GIVEN LRECL.
 %
 % METHOD:+  THIS PROGRAM TAKES A LOGICAL RECORD LENGTH WITH OR WITHOUT
 +           KEYS AND COMPUTES ALL POSSIBLE BLOCK SIZES.  IT THEN
 +           EVALUATES THEIR SPACE EFFECTIVENESS ON FOUR DIRECT ACCESS
 +           DEVICE TYPES.  IT THEN SORTS THEM IN BEST FIRST ORDER FOR
 +           THE DEVICE TYPES SELECTED AND PUTS OUT THE INFORMATION IN
 +           AN ISPF TABLE.
 +
 % TABLE HEADER DEFINITIONS:
 %  BKNG-+BLOCKING FACTOR, NUMBER OF LOGICAL RECORDS IN PHYSICAL RECORD.
 %  BLKSIZE-+PHYSICAL RECORD SIZE (LRECL * BKNG).
 %  RATING-+RELATIVE UTILIZATION (USED-OVERHEAD) ON CHOSEN DEVICE TYPES.
 %  UNIT/CON-+UNITS FROM PRIOR PANEL AND WHETHER CONSIDERED FOR RATING.
 %  #BLKS/TRK-+NUMBER OF PHYSICAL RECORDS WHICH WILL FIT ON UNITS TRACK.
 %  BYTES (THE FOLLOWING REFER TO A TRACK OF A GIVEN DEVICE/UNIT):
 %    USED-+BYTES USED (#BLKS/TRK * BLKSIZE).
 %    WASTED-+USABLE BYTES WASTED ON DEVICE TRACK DUE TO BLKSIZE.
 %    OVERHEAD-+BYTES REQUIRED BY DEVICE TYPE FOR #BLKS/TRK PLUS WASTED.
 )END
 */

 END BLKSIZE;
*PROCESS NM;
 RATESRT:  PROCEDURE(TABLE, UPPER_BOUND) OPTIONS(REENTRANT) REORDER;

 DECLARE  IDRATES  CHAR(35) VARYING STATIC EXTERNAL
     INIT('RATESRT V1.0  BY CLYDE THOMAS ZUBER');

 /*********************************************************************/
 /*                                                                   */
 /* DESCRIPTION OF ALGORITH:                                          */
 /*                                                                   */
 /* THIS PROCEDURE USES A HEAP SORT ALGORITHM TO SORT AN ARRAY INTO   */
 /* NON-ASCENDING ORDER.  THE ARRAY IS CONSIDERED LOGICALLY TO BE A   */
 /* BINARY TREE REPRESENTATION.  THE NODES ARE NUMBERED FROM LEFT TO  */
 /* RIGHT STARTING WITH THE FIRST LEVEL.  THE FIRST NODE (THE FIRST   */
 /* POSITION IN THE ARRAY) MUST BE NUMBERED ONE SO THE CALLER         */
 /* MUST BE RESPONSIBLE TO ADJUST THE ARRAY LOWER BOUND ACCORDINGLY.  */
 /* THIS ARRAY REPRESENTATION IMPLIES THAT THE TREE IS COMPLETE (THE  */
 /* ONLY NODES THAT CAN BE MISSING ARE ON THE LAST LEVEL RIGHT HAND   */
 /* SIDE) AND THAT A LEFT CHILD IS AT TWO TIMES ITS PARENT'S          */
 /* POSITION.  A RIGHT CHILD IS AT TWO TIMES ITS POSITION PLUS ONE.   */
 /* IF THAT COMPUTATION IS OUTSIDE THE ARRAY'S HIGHER BOUNDARY IT     */
 /* MEANS THE CHILD DOES NOT EXIST.                                   */
 /*      HEAP SORT MAY BE REGARDED AS A TWO STAGE METHOD.  FIRST THE  */
 /* TREE REPRESENTING THE ARRAY IS CONVERTED INTO A HEAP.  A HEAP IS  */
 /* DEFINED TO BE A COMPLETE BINARY TREE WITH THE PROPERTY THAT THE   */
 /* VALUE OF EACH NODE IS AT LEAST AS LARGE AS THE VALUE OF ITS       */
 /* CHILDREN NODES (IF THEY EXIST).  THIS IMPLIES THAT THE ROOT OF    */
 /* THE TREE HAS THE LARGEST KEY IN THE TREE.  IN THE SECOND STAGE    */
 /* THE FINALE SEQUENCE IS CREATED BY REMOVING THE ROOT SUCCESSIVELY  */
 /* FROM CONSIDERATION (SEE NOTES BELOW), AND RESTRUCTURING THE       */
 /* REMAINING TREE INTO A HEAP.                                       */
 /*                                                                   */
 /* ANALYSIS OF ALGORITHM:                                            */
 /*                                                                   */
 /* HEAPSORT HAS THE ADVANTAGE OF HAVING ITS WORST CASE COMPUTING     */
 /* TIME ALMOST THE SAME AS ITS AVERAGE COMPUTING TIME WHICH IS       */
 /* O(N LOG2 N).  IT ALSO ONLY USES A FIXED AMOUNT OF EXTRA STORAGE   */
 /* WHICH DOES NOT VARY WITH THE SIZE OF N.                           */
 /*                                                                   */
 /*********************************************************************/
1/* RATING IS SEQUENCE OF KEYS TO BE SORTED (LOGICAL TREE) */
 DECLARE
     1  TABLE(*),
        2  FILLER   FIXED BINARY(31),
        2  RATING   FIXED BINARY(31);

 /* HIGHEST POSITION OF THE ARRAY */
 DECLARE  UPPER_BOUND  FIXED BINARY(31);

 /* TEMPORARY STORAGE FOR SWAPPING ARRAY VALUES */
 DECLARE
     1  HOLD_ROOT,
        2  FILLER   FIXED BINARY(31),
        2  HR_KEY   FIXED BINARY(31);

 /* INDICATES A NODE POSITION */
 DECLARE  NODE  FIXED BINARY(31);

 /* COMPLIER FUNCTIONS */
 DECLARE  (FLOOR, LENGTH)  BUILTIN;
1/* THE FIRST DO GROUP IN THIS PROCEDURE CONVERTS THE ARRAY SO THAT
    THE LEFT AND RIGHT SUBTREES SATISFY THE HEAP PROPERTY OF EACH
    PARENT BEING GREATER THAN ITS CHILDREN.  TO ACCOMPLISH THIS IT
    STARTS FROM THE BOTTOM OF THE TREE UP AS LEAVES ARE IMPLICITLY
    HEAPS. */

 INITIAL_HEAPS:
 DO NODE = UPPER_BOUND/2 TO 2 BY -1;
     CALL SIFTUP(NODE, UPPER_BOUND);
     END INITIAL_HEAPS;


 /* THIS SECOND DO GROUP TAKES AN "ALMOST HEAP" WHERE THE LEFT AND
    RIGHT SUBTREES ARE HEAPS BUT THE ROOT IS NOT AND CONVERTS IT INTO
    A HEAP.  THE FIRST TIME IT IS DONE IT FINDS THE GREATEST MEMBER
    OF THE ARRAY.  THIS MEMBER IS THEN REMOVED FROM CONSIDERATION
    AND ANOTHER MEMBER IS PUT IN THE ROOT POSITION AND THE PROCESS
    REPEATED FINDING THE SECOND GREATEST IN THE ARRAY.  SINCE THE TREE
    SHRINKS IN SIZE BY ONE EACH TIME THE LEFTOVER STORAGE AT THE END
    OF THE ARRAY IS USED TO STORE THOSE REMOVED FROM CONSIDERATION
    (WHICH IS WHERE WE WANTED THEM ANYWAY). */

 DO NODE = UPPER_BOUND TO 2 BY -1;
     CALL SIFTUP(1, NODE);

     /* REMOVE THE ROOT FROM CONSIDERATION */
     HOLD_ROOT = TABLE(1);
     TABLE(1) = TABLE(NODE);
     TABLE(NODE) = HOLD_ROOT;
     END;
1SIFTUP:  PROCEDURE(ROOT, EXTENT);

 /*********************************************************************/
 /*                                                                   */
 /* THIS PROCEDURE IS INTERNAL TO RATESRT.  IT ASSUMES THAT THE TREE  */
 /* INDICATED BY THE PARAMETERS SATISFIES THE HEAP CHARACTERIC IN     */
 /* ITS LEFT AND RIGHT SUBTREES.  THE ROOT IS THEN "SIFTED" TO A      */
 /* POSITION WHERE IT ALSO SATISFIES THE HEAP PROPERTY BY SWAPPING IT */
 /* WITH ITS SMALLEST CHILD UP THE TREE (REPEATEDLY).  HOLD_ROOT IS   */
 /* USED HOWEVER TO KEEP FROM HAVING TO PHYSICALLY RELOCATE THE ROOT  */
 /* UNTIL ITS FINAL POSITION IS KNOWN.                                */
 /*                                                                   */
 /*********************************************************************/

 /* THIS IS THE ROOT OF THE TREE (OR SUBTREE) FOR CONSIDERATION */
 DECLARE  ROOT  FIXED BINARY(31);

 /* THIS DEFINES THE LAST NODE IN THE TREE (OR SUBTREE) */
 DECLARE  EXTENT  FIXED BINARY(31);

 /* INDICATES THE NODE POSITION OF A CHILD */
 DECLARE  CHILD  FIXED BINARY(31);
1/* SAVE ROOT VALUE SO WE CAN MOVE OTHER ROOTS DOWN THE TREE */
 HOLD_ROOT = TABLE(ROOT);

 /* LOOK FOR FIRST CHILD */
 CHILD = 2 * ROOT;

 CLIMB_TREE:  /* ONLY WHILE A CHILD EXISTS */
 DO WHILE(CHILD <= EXTENT);

     /* DOES A RIGHT CHILD ALSO EXIST */
     IF CHILD < EXTENT
         /* YES, WHICH CHILD IS LARGER? */
         THEN IF RATING(CHILD+1) < RATING(CHILD)
                  /* RIGHT WINS THIS TIME */
                  THEN CHILD = CHILD + 1;

     /* COMPARE THE ROOT WITH ITS SMALLEST CHILD IF IT'S SMALLER
        THEN WE HAVE FOUND ITS PLACE AND ARE FINISHED */
     IF RATING(CHILD) >= HR_KEY
         THEN DO;
              /* PUT IT IN ITS FINAL POSITION */
              TABLE(FLOOR(CHILD/2)) = HOLD_ROOT;
              RETURN;
              END;

     /* MAKE THE SMALLEST CHILD ITS PARENT'S OLD POSITION, ROOT IS
        NOW ASSUMED TO BE WHERE SMALLEST CHILD WAS EVEN THOUGH WE DON'T
        PHYSICALLY MOVE IT THERE */
     TABLE(FLOOR(CHILD/2)) = TABLE(CHILD);
     CHILD = 2 * CHILD;

     END CLIMB_TREE;

 /* NO MORE CHILDREN SO WE PUT ROOT IN THE LAST CHILDLESS PARENT AT THE
    BOTTOM OF THE TREE */
 TABLE(FLOOR(CHILD/2)) = HOLD_ROOT;
 END SIFTUP;

 END RATESRT;
