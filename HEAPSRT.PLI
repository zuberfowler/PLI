*PROCESS NM;
 HEAPSRT:  PROCEDURE(ARRAY, UPPER_BOUND) OPTIONS(REENTRANT) REORDER;

 DECLARE  IDHEAPS  CHAR(35) VARYING STATIC EXTERNAL
     INIT('HEAPSRT V1.0  BY CLYDE THOMAS ZUBER');

 /*********************************************************************/
 /*                                                                   */
 /* DESCRIPTION OF ALGORITH:                                          */
 /*                                                                   */
 /* THIS PROCEDURE USES A HEAP SORT ALGORITHM TO SORT AN ARRAY INTO   */
 /* NON-DESCENDING ORDER.  THE ARRAY IS CONSIDERED LOGICALLY TO BE A  */
 /* BINARY TREE REPRESENTATION.  THE NODES ARE NUMBERED FROM LEFT TO  */
 /* RIGHT STARTING WITH THE FIRST LEVEL.  THE FIRST NODE (THE FIRST   */
 /* POSITION IN THE ARRAY) MUST BE NUMBERED ONE SO THE CALLER         */
 /* MUST BE RESPONSIBLE TO ADJUST THE ARRAY LOWER BOUND ACCORDINGLY.  */
 /* THIS ARRAY REPRESENTATION IMPLIES THAT THE TREE IS COMPLETE (THE  */
 /* ONLY NODES THAT CAN BE MISSING ARE ON THE LAST LEVEL RIGHT HAND   */
 /* SIDE) AND THAT A LEFT CHILD IS AT TWO TIMES ITS PARENT'S          */
 /* POSITION.  A RIGHT CHILD IS AT TWO TIMES ITS POSITION PLUS ONE.   */
 /* IF THAT COMPUTATION IS OUTSIDE THE ARRAY'S HIGHER BOUNDARY IT     */
 /* MEANS THE CHILD DOES NOT EXIST.                                   */
 /*      HEAP SORT MAY BE REGARDED AS A TWO STAGE METHOD.  FIRST THE  */
 /* TREE REPRESENTING THE ARRAY IS CONVERTED INTO A HEAP.  A HEAP IS  */
 /* DEFINED TO BE A COMPLETE BINARY TREE WITH THE PROPERTY THAT THE   */
 /* VALUE OF EACH NODE IS AT LEAST AS LARGE AS THE VALUE OF ITS       */
 /* CHILDREN NODES (IF THEY EXIST).  THIS IMPLIES THAT THE ROOT OF    */
 /* THE TREE HAS THE LARGEST KEY IN THE TREE.  IN THE SECOND STAGE    */
 /* THE FINALE SEQUENCE IS CREATED BY REMOVING THE ROOT SUCCESSIVELY  */
 /* FROM CONSIDERATION (SEE NOTES BELOW), AND RESTRUCTURING THE       */
 /* REMAINING TREE INTO A HEAP.                                       */
 /*                                                                   */
 /* ANALYSIS OF ALGORITHM:                                            */
 /*                                                                   */
 /* HEAPSORT HAS THE ADVANTAGE OF HAVING ITS WORST CASE COMPUTING     */
 /* TIME ALMOST THE SAME AS ITS AVERAGE COMPUTING TIME WHICH IS       */
 /* O(N LOG2 N).  IT ALSO ONLY USES A FIXED AMOUNT OF EXTRA STORAGE   */
 /* WHICH DOES NOT VARY WITH THE SIZE OF N.                           */
 /*                                                                   */
 /*********************************************************************/
1/* SEQUENCE OF KEYS TO BE SORTED (LOGICAL TREE) */
 DECLARE  ARRAY(*)  CHAR(*);

 /* HIGHEST POSITION OF THE ARRAY */
 DECLARE  UPPER_BOUND  FIXED BINARY(15);

 /* TEMPORARY STORAGE FOR SWAPPING ARRAY VALUES */
 DECLARE  HOLD_ROOT  CHAR(*) CONTROLLED;

 /* INDICATES A NODE POSITION */
 DECLARE  NODE  FIXED BINARY(15);

 /* COMPLIER FUNCTIONS */
 DECLARE  (FLOOR, LENGTH)  BUILTIN;
1/* ALLOCATE WORK IDENTIFIER */
 ALLOCATE HOLD_ROOT CHAR(LENGTH(ARRAY(1)));


 /* THE FIRST DO GROUP IN THIS PROCEDURE CONVERTS THE ARRAY SO THAT
    THE LEFT AND RIGHT SUBTREES SATISFY THE HEAP PROPERTY OF EACH
    PARENT BEING GREATER THAN ITS CHILDREN.  TO ACCOMPLISH THIS IT
    STARTS FROM THE BOTTOM OF THE TREE UP AS LEAVES ARE IMPLICITLY
    HEAPS. */

 INITIAL_HEAPS:
 DO NODE = UPPER_BOUND/2 TO 2 BY -1;
     CALL SIFTUP(NODE, UPPER_BOUND);
     END INITIAL_HEAPS;


 /* THIS SECOND DO GROUP TAKES AN "ALMOST HEAP" WHERE THE LEFT AND
    RIGHT SUBTREES ARE HEAPS BUT THE ROOT IS NOT AND CONVERTS IT INTO
    A HEAP.  THE FIRST TIME IT IS DONE IT FINDS THE GREATEST MEMBER
    OF THE ARRAY.  THIS MEMBER IS THEN REMOVED FROM CONSIDERATION
    AND ANOTHER MEMBER IS PUT IN THE ROOT POSITION AND THE PROCESS
    REPEATED FINDING THE SECOND GREATEST IN THE ARRAY.  SINCE THE TREE
    SHRINKS IN SIZE BY ONE EACH TIME THE LEFTOVER STORAGE AT THE END
    OF THE ARRAY IS USED TO STORE THOSE REMOVED FROM CONSIDERATION
    (WHICH IS WHERE WE WANTED THEM ANYWAY). */

 DO NODE = UPPER_BOUND TO 2 BY -1;
     CALL SIFTUP(1, NODE);

     /* REMOVE THE ROOT FROM CONSIDERATION */
     HOLD_ROOT = ARRAY(1);
     ARRAY(1) = ARRAY(NODE);
     ARRAY(NODE) = HOLD_ROOT;
     END;
1SIFTUP:  PROCEDURE(ROOT, EXTENT);

 /*********************************************************************/
 /*                                                                   */
 /* THIS PROCEDURE IS INTERNAL TO HEAPSRT.  IT ASSUMES THAT THE TREE  */
 /* INDICATED BY THE PARAMETERS SATISFIES THE HEAP CHARACTERIC IN     */
 /* ITS LEFT AND RIGHT SUBTREES.  THE ROOT IS THEN "SIFTED" TO A      */
 /* POSITION WHERE IT ALSO SATISFIES THE HEAP PROPERTY BY SWAPPING IT */
 /* WITH ITS GREATEST CHILD UP THE TREE (REPEATEDLY).  HOLD_ROOT IS   */
 /* USED HOWEVER TO KEEP FROM HAVING TO PHYSICALLY RELOCATE THE ROOT  */
 /* UNTIL ITS FINAL POSITION IS KNOWN.                                */
 /*                                                                   */
 /*********************************************************************/

 /* THIS IS THE ROOT OF THE TREE (OR SUBTREE) FOR CONSIDERATION */
 DECLARE  ROOT  FIXED BINARY(15);

 /* THIS DEFINES THE LAST NODE IN THE TREE (OR SUBTREE) */
 DECLARE  EXTENT  FIXED BINARY(15);

 /* INDICATES THE NODE POSITION OF A CHILD */
 DECLARE  CHILD  FIXED BINARY(15);
1/* SAVE ROOT VALUE SO WE CAN MOVE OTHER ROOTS DOWN THE TREE */
 HOLD_ROOT = ARRAY(ROOT);

 /* LOOK FOR FIRST CHILD */
 CHILD = 2 * ROOT;

 CLIMB_TREE:  /* ONLY WHILE A CHILD EXISTS */
 DO WHILE(CHILD <= EXTENT);

     /* DOES A RIGHT CHILD ALSO EXIST */
     IF CHILD < EXTENT
         /* YES, WHICH CHILD IS LARGER? */
         THEN IF ARRAY(CHILD+1) > ARRAY(CHILD)
                  /* RIGHT WINS THIS TIME */
                  THEN CHILD = CHILD + 1;

     /* COMPARE THE ROOT WITH ITS LARGEST CHILD IF IT'S GREATER
        THEN WE HAVE FOUND ITS PLACE AND ARE FINISHED */
     IF ARRAY(CHILD) <= HOLD_ROOT
         THEN DO;
              /* PUT IT IN ITS FINAL POSITION */
              ARRAY(FLOOR(CHILD/2)) = HOLD_ROOT;
              RETURN;
              END;

     /* MAKE THE GREATEST CHILD ITS PARENT'S OLD POSITION, ROOT IS
        NOW ASSUMED TO BE WHERE GREATEST CHILD WAS EVEN THOUGH WE DON'T
        PHYSICALLY MOVE IT THERE */
     ARRAY(FLOOR(CHILD/2)) = ARRAY(CHILD);
     CHILD = 2 * CHILD;

     END CLIMB_TREE;

 /* NO MORE CHILDREN SO WE PUT ROOT IN THE LAST CHILDLESS PARENT AT THE
    BOTTOM OF THE TREE */
 ARRAY(FLOOR(CHILD/2)) = HOLD_ROOT;
 END SIFTUP;

 END HEAPSRT;
